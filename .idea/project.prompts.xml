<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="PromptTemplates">
    <option name="prompts">
      <list>
        <PromptTemplate>
          <option name="enabled" value="true" />
          <option name="name" value="recap of our next goals)" />
          <option name="text" value="recap of our next goals: (weve just completed )&#10;**Goal:** Implement reliable push-up detection and a basic mechanism to grant time based on detected push-ups.&#10;&#10;*   **1.1: Project Setup (COMPLETED)**&#10;    *   New Android Studio project.&#10;    *   Basic `MainActivity` and `PushupActivity` layouts.&#10;    *   ViewBinding enabled.&#10;*   **1.2: CameraX Integration (COMPLETED)**&#10;    *   Request Camera permissions.&#10;    *   Set up `PreviewView` in `PushupActivity`.&#10;    *   Start camera and display preview.&#10;*   **1.3: ML Kit Pose Detection Integration (COMPLETED)**&#10;    *   Add ML Kit Pose Detection dependency.&#10;    *   Configure `PoseDetector`.&#10;    *   Process camera frames for poses.&#10;    *   Draw landmarks on an overlay (for debugging/visualization).&#10;*   **1.4: Push-up Counting Logic (COMPLETED)**&#10;    *   Define logic to identify push-up states (up, down) based on landmark positions (e.g., shoulders, elbows, hips).&#10;    *   Implement a counter that increments on valid push-up completion.&#10;    *   Display push-up count in `PushupActivity`.&#10;*   **1.5: Time Granting Mechanism (`TimeBankManager`) (COMPLETED)**&#10;    *   Create `TimeBankManager.kt` using SharedPreferences.&#10;    *   Methods: `addTimeSeconds(seconds: Int)`, `getTimeSeconds(): Int`, `clearTimeBank()`.&#10;    *   In `PushupActivity`, after push-ups, grant time (e.g., 10 seconds per push-up) using `TimeBankManager`.&#10;*   **1.6: Basic UI in `MainActivity` (COMPLETED)**&#10;    *   Display current time from `TimeBankManager`.&#10;    *   Button to launch `PushupActivity` to &quot;Earn More Time.&quot;&#10;    *   Button to &quot;Reset Time.&quot;&#10;&#10;---&#10;&#10;## Phase 2: App Blocking &amp; Timer Service (COMPLETED)&#10;&#10;**Goal:** Implement the app blocking mechanism using an Accessibility Service and a Foreground Service to manage the countdown timer.&#10;&#10;*   **2.1: App Selection UI (`AppSelectionActivity`) (COMPLETED)**&#10;    *   Create `AppSelectionActivity` and `item_app.xml` layout.&#10;    *   `RecyclerView` to list user-installed, non-system, launchable apps.&#10;    *   Display app icon, name, and a `CheckBox` for each.&#10;    *   Save selected app package names to SharedPreferences.&#10;    *   Handle package visibility requirements (QUERY_ALL_PACKAGES permission).&#10;    *   Exclude own app from the list.&#10;    *   Refined UI to handle system insets (e.g., camera cutout).&#10;*   **2.2: Accessibility Service (`AppBlockerService`) Setup (COMPLETED)**&#10;    *   Create `AppBlockerService.kt`.&#10;    *   Configure `accessibility_service_config.xml`.&#10;    *   Declare service in `AndroidManifest.xml`.&#10;    *   Guide user to enable the service via `MainActivity`.&#10;*   **2.3: App Launch Detection (COMPLETED)**&#10;    *   In `AppBlockerService`, override `onAccessibilityEvent`.&#10;    *   Listen for `TYPE_WINDOW_STATE_CHANGED` or `TYPE_WINDOWS_CHANGED`.&#10;    *   Identify the foreground app's package name.&#10;*   **2.4: Blocking Logic (COMPLETED)**&#10;    *   If foreground app is in the saved &quot;locked apps&quot; list from SharedPreferences:&#10;        *   Check `TimeBankManager`. If time &lt;= 0, launch `PushupActivity` (passing the blocked app's name/package).&#10;        *   If time &gt; 0, start `TimerService`.&#10;*   **2.5: Timer Foreground Service (`TimerService`) (COMPLETED)**&#10;    *   Create `TimerService.kt`.&#10;    *   Run as a foreground service with a persistent notification (showing time remaining or generic message).&#10;    *   Input: duration to run.&#10;    *   Countdown second by second.&#10;    *   Update `TimeBankManager` every second.&#10;    *   Broadcast an Intent if time runs out while a locked app is still in foreground.&#10;*   **2.6: `AppBlockerService` and `TimerService` Interaction (COMPLETED)**&#10;    *   `AppBlockerService` starts `TimerService` when a locked app is opened with available time.&#10;    *   `AppBlockerService` stops `TimerService` if user navigates away from the timed locked app.&#10;    *   If `TimerService` broadcasts &quot;time up,&quot; `AppBlockerService` re-blocks by launching `PushupActivity`.&#10;*   **2.7: Broadcast for Locked App List Update (COMPLETED)**&#10;    *   When selections are saved in `AppSelectionActivity`, send a broadcast.&#10;    *   `AppBlockerService` listens for this broadcast to reload its list of locked apps.&#10;&#10;---&#10;&#10;## Phase 3: UI Refinement &amp; Robustness (COMPLETED)&#10;&#10;**Goal:** Improve user experience, fix bugs, and ensure core features are stable.&#10;&#10;*   **3.1: `MainActivity` ViewBinding &amp; Polish (COMPLETED)**&#10;    *   Full ViewBinding adoption.&#10;    *   Clear display of time.&#10;    *   Functional buttons for earning time, selecting apps, resetting time.&#10;    *   Clear guidance for enabling Accessibility Service.&#10;*   **3.2: `AppSelectionActivity` Robustness (COMPLETED)**&#10;    *   Fix &quot;ghost selection&quot; issues in `RecyclerView` by correctly handling view recycling and listener management in `AppSelectionAdapter`.&#10;    *   Ensure explicit save button works as intended.&#10;    *   UI respects system insets (camera cutout, navigation bar).&#10;*   **3.3: `PushupActivity` UI Enhancements (COMPLETED)**&#10;    *   Display name of the blocked app when launched by `AppBlockerService`.&#10;    *   Clear visual feedback for push-up counting.&#10;*   **3.4: Notification Permission Handling (Android 13+) (COMPLETED)**&#10;    *   Request `POST_NOTIFICATIONS` permission in `MainActivity`.&#10;    *   Handle granted/denied cases gracefully.&#10;*   **3.5: Comprehensive Testing &amp; Bug Fixing (COMPLETED)**&#10;    *   Test app locking/unlocking with and without time.&#10;    *   Test app selection persistence.&#10;    *   Test Accessibility Service enable/disable flow.&#10;    *   Test `TimerService` start/stop and notification behavior.&#10;    *   Test push-up detection accuracy.&#10;    *   Test UI responsiveness and absence of crashes.&#10;&#10;---&#10;&#10;## Phase 4: Advanced Features &amp; Polish (Current Phase)&#10;&#10;**Goal:** Add more sophisticated features, improve user engagement, and further polish the application.&#10;&#10;*   **4.1: Grace Period &amp; Blocking Interstitial Menu** (COMPLETED)&#10;    *   **4.1.1: Implement Grace Period Logic**&#10;        *   **Objective:** Allow users a once-daily 30-second grace period to use a blocked app without earning time.&#10;        *   **Steps:**&#10;            1.  Define SharedPreferences keys: `PREF_LAST_GRACE_PERIOD_USED_TIMESTAMP` (Long), `PREF_GRACE_PERIOD_ACTIVE_UNTIL_TIMESTAMP` (Long).&#10;            2.  Create `GracePeriodManager.kt` (or add to `TimeBankManager.kt`).&#10;            3.  Implement `GracePeriodManager.canUseGracePeriodToday(): Boolean`:&#10;                *   Reads `PREF_LAST_GRACE_PERIOD_USED_TIMESTAMP`.&#10;                *   Compares with current date. Returns true if no grace period used today or timestamp is from a previous day.&#10;            4.  Implement `GracePeriodManager.activateGracePeriod(durationSeconds: Int = 30)`:&#10;                *   If `canUseGracePeriodToday()` is true:&#10;                    *   Set `PREF_LAST_GRACE_PERIOD_USED_TIMESTAMP` to `System.currentTimeMillis()`.&#10;                    *   Set `PREF_GRACE_PERIOD_ACTIVE_UNTIL_TIMESTAMP` to `System.currentTimeMillis() + durationSeconds * 1000`.&#10;                    *   Return true (activated).&#10;                *   Else, return false.&#10;            5.  Implement `GracePeriodManager.isGracePeriodActive(): Boolean`:&#10;                *   Reads `PREF_GRACE_PERIOD_ACTIVE_UNTIL_TIMESTAMP`.&#10;                *   Returns true if current time is before this timestamp.&#10;            6.  In `AppBlockerService`, before deciding to block or start `TimerService`:&#10;                *   If `GracePeriodManager.isGracePeriodActive()`, allow app access and do not start `TimerService` (or start it in a special &quot;grace&quot; mode if separate tracking is needed).&#10;    *   **4.1.2: Design &amp; Implement Blocking Interstitial Menu/Dialog**&#10;        *   **Objective:** When a blocked app is launched with zero time (and grace period not active), show a menu instead of directly launching `PushupActivity`.&#10;        *   **Steps:**&#10;            1.  Create a new Activity (`InterstitialBlockActivity.kt`) or a custom DialogFragment.&#10;            2.  Layout (`activity_interstitial_block.xml`):&#10;                *   Display blocked app name (passed via Intent).&#10;                *   Button: &quot;Use Daily Grace Period (30s)&quot; (ID: `btnUseGracePeriod`).&#10;                *   Button: &quot;Earn More Time&quot; (ID: `btnEarnTime`).&#10;                *   (Future: Placeholder for choosing different activities).&#10;            3.  In `AppBlockerService`, when blocking is triggered (time=0, grace not active):&#10;                *   Instead of `Intent(this, PushupActivity::class.java)`, launch `InterstitialBlockActivity`.&#10;                *   Pass the blocked app's package name and display name.&#10;            4.  In `InterstitialBlockActivity.onCreate()`:&#10;                *   Retrieve blocked app info.&#10;                *   Check `GracePeriodManager.canUseGracePeriodToday()`. Enable/disable `btnUseGracePeriod` accordingly.&#10;                *   `btnUseGracePeriod.setOnClickListener`:&#10;                    *   Call `GracePeriodManager.activateGracePeriod()`.&#10;                    *   If successful, show a Toast, `finish()` the interstitial activity (allowing access to the underlying app).&#10;                    *   `AppBlockerService` will then see `isGracePeriodActive()` as true on next check.&#10;                *   `btnEarnTime.setOnClickListener`:&#10;                    *   Start `PushupActivity` (pass blocked app info).&#10;                    *   `finish()` the interstitial activity.&#10;*   **4.2: Enhanced Non-Dismissible Timer Notification** ( LAST COMPLETED)&#10;    *   **Objective:** Prevent the `TimerService` notification from being accidentally swiped away while timing an app.&#10;    *   **Steps:**&#10;        1.  In `TimerService.createNotification()`:&#10;            *   When building the notification with `NotificationCompat.Builder`, call `setOngoing(true)`.&#10;        2.  Ensure `stopForeground(true)` or `stopForeground(STOP_FOREGROUND_REMOVE)` is called in `TimerService.onDestroy()` or when the timer legitimately stops, to allow the notification to be removed.&#10;        3.  Test scenarios: User leaves app, time expires, time is added manually, grace period starts. Ensure notification behaves correctly.&#10;*   **4.3: Persistent Timer State Across Reboots** (NEXT UP)&#10;    *   **Objective:** Restore active timers if the phone reboots.&#10;    *   **Steps:**&#10;        1.  Define SharedPreferences keys: `PREF_ACTIVE_TIMER_TARGET_PACKAGE` (String), `PREF_ACTIVE_TIMER_END_TIMESTAMP` (Long).&#10;        2.  In `TimerService.onStartCommand()`:&#10;            *   When a timer starts for a specific app, save its package name to `PREF_ACTIVE_TIMER_TARGET_PACKAGE` and calculated `System.currentTimeMillis() + durationMillis` to `PREF_ACTIVE_TIMER_END_TIMESTAMP`.&#10;        3.  In `TimerService.onDestroy()` or when stopping normally:&#10;            *   Clear these SharedPreferences keys.&#10;        4.  Create `BootCompletedReceiver.kt` extending `BroadcastReceiver`.&#10;        5.  In `BootCompletedReceiver.onReceive()`:&#10;            *   Check for `Intent.ACTION_BOOT_COMPLETED`.&#10;            *   Read `PREF_ACTIVE_TIMER_TARGET_PACKAGE` and `PREF_ACTIVE_TIMER_END_TIMESTAMP`.&#10;            *   If data exists and `PREF_ACTIVE_TIMER_END_TIMESTAMP` is in the future:&#10;                *   Calculate remaining duration.&#10;                *   Start `TimerService` with the target package and remaining duration.&#10;        6.  Declare receiver in `AndroidManifest.xml`:&#10;7.  Add permission in `AndroidManifest.xml`: `&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;`.&#10;*   **4.4: Basic Usage Statistics on Main Screen**&#10;    *   **Objective:** Display total time spent on each blocked app and total push-ups done.&#10;    *   **Steps:**&#10;        1.  **Track Time Spent per Blocked App:**&#10;            *   In `TimerService`, when it stops timing an app (or periodically), calculate elapsed time for that session.&#10;            *   Store accumulated time in SharedPreferences. A good way is to use `Map&lt;String, Long&gt;` serialized as a JSON string or individual keys like `PREF_TIME_SPENT_PKGNAME_`.&#10;            *   Key: `PREF_TIME_SPENT_PREFIX + packageName` (String), Value: `totalMilliseconds` (Long).&#10;        2.  **Track &quot;Activity Units&quot; (Push-ups):**&#10;            *   In `PushupActivity` (or where time is granted from an activity):&#10;                *   When push-ups are completed, get the count.&#10;                *   Increment a SharedPreferences value: `PREF_TOTAL_PUSHUPS_DONE` (Long).&#10;        3.  **Display Stats in `MainActivity`:**&#10;            *   Add `TextViews` or a simple `RecyclerView` to `activity_main.xml` to display:&#10;                *   &quot;Total Push-ups: [count]&quot;&#10;                *   &quot;Time Spent on Apps:&quot;&#10;                *   &quot;[App Name 1]: [X]m [Y]s&quot;&#10;                *   &quot;[App Name 2]: [A]m [B]s&quot;&#10;            *   In `MainActivity.onResume()` or a dedicated update function:&#10;                *   Load `PREF_TOTAL_PUSHUPS_DONE`.&#10;                *   Load time spent for each locked app (iterate through known locked apps or scan prefs for the prefix).&#10;                *   Format and display the data.&#10;*   **4.5: Customizable Time Earning (Basic)**&#10;    *   **Objective:** Allow users to define how many seconds are earned per push-up.&#10;    *   **Steps:**&#10;        1.  Create a simple settings UI (could be a new `SettingsActivity` or directly in `MainActivity` for now).&#10;        2.  Add an `EditText` (inputType number) for &quot;Seconds per Push-up.&quot;&#10;        3.  Save this value to SharedPreferences (e.g., `PREF_SECONDS_PER_PUSHUP`, default to 10).&#10;        4.  In `PushupActivity`, when calculating `timeEarned = pushupCount * secondsPerPushup`:&#10;            *   Read `PREF_SECONDS_PER_PUSHUP` from SharedPreferences.&#10;            *   Use this value in the calculation.&#10;&#10;---&#10;&#10;## Phase 5: Further Enhancements &amp; Release Prep (Future)&#10;&#10;*   **5.1: Multiple Earning Activities:**&#10;    *   Abstract `PushupActivity` logic.&#10;    *   Allow users to choose different activities (e.g., squats, jumping jacks) from the interstitial menu.&#10;    *   Implement detection for new activities if using ML Kit, or simpler time-based earning.&#10;*   **5.2: In-App Settings Screen:**&#10;    *   Consolidate all settings (seconds per activity, notification preferences, etc.).&#10;*   **5.3: Error Handling &amp; Edge Cases:**&#10;    *   More robust error handling throughout.&#10;    *   Test thoroughly on different devices and Android versions.&#10;*   **5.4: UI/UX Polish:**&#10;    *   Animations, transitions.&#10;    *   Material You theming.&#10;    *   Accessibility improvements (content descriptions, etc.).&#10;*   **5.5: Code Cleanup &amp; Refactoring:**&#10;    *   Address TODOs, optimize performance.&#10;    *   Add comments and documentation.&#10;*   **5.6: Testing:**&#10;    *   Unit tests for logic classes (`TimeBankManager`, `GracePeriodManager`).&#10;    *   UI tests (Espresso) for key flows.&#10;*   **5.7: Release Preparation:**&#10;    *   App icon, screenshots, feature graphic.&#10;    *   Privacy policy.&#10;    *   Google Play Console setup and declaration for sensitive permissions (Accessibility, Query All Packages).&#10;&#10;---" />
        </PromptTemplate>
      </list>
    </option>
  </component>
</project>